<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>MSX MV2 to MP4 Web Demuxer</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #1e1e1e; color: #fff; padding: 40px; max-width: 800px; margin: 0 auto; }
        .box { background: #2d2d2d; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        button { background: #0078D7; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 10px; }
        button:hover { background: #005a9e; }
        button:disabled { background: #555; cursor: not-allowed; }
        pre { background: #000; padding: 15px; border-radius: 4px; overflow-y: auto; max-height: 300px; color: #00ff00; font-family: monospace; }
        #downloadBtn { display: inline-block; background: #28a745; text-decoration: none; color: white; padding: 10px 20px; border-radius: 4px; display: none; margin-top: 10px; }
    </style>
    
    <script src="ffmpeg.js"></script>
</head>
<body>

    <h1>ğŸ¬ MV2 Web Demuxer</h1>
    <div class="box">
        <input type="file" id="mv2file" accept=".MV2,.mv2" />
        <br>
        <button id="startBtn">ë³€í™˜ ì‹œì‘ (MP4)</button>
        <a id="downloadBtn" download="output.mp4">â†“ MP4 ë‹¤ìš´ë¡œë“œ</a>
    </div>

    <div class="box">
        <h3>ì§„í–‰ ìƒí™© ë¡œê·¸</h3>
        <pre id="log">ëŒ€ê¸° ì¤‘...</pre>
    </div>

    <script>
        const { FFmpeg } = FFmpegWASM;
        const ffmpeg = new FFmpeg();
        const logEl = document.getElementById('log');
        const startBtn = document.getElementById('startBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        function log(msg) {
            logEl.textContent += `\n[System] ${msg}`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        ffmpeg.on('log', ({ message }) => {
            logEl.textContent += `\n[FFmpeg] ${message}`;
            logEl.scrollTop = logEl.scrollHeight;
        });

        function rgb333_to_888(r, g, b) {
            return [Math.floor(r * 255 / 7), Math.floor(g * 255 / 7), Math.floor(b * 255 / 7)];
        }

        async function demuxMV2(arrayBuffer) {
            const data = new Uint8Array(arrayBuffer);
            const blockSize = 16384;
            let remainingBytes = data.length - 512;
            let numBlocks = remainingBytes >= 15872 ? 1 + Math.floor((remainingBytes - 15872) / 16384) : 0;

            const videoBuffer = new Uint8Array(numBlocks * 256 * 192 * 3);
            let videoOffset = 0;
            let audioChunks = [];
            let palette = Array(16).fill([0, 0, 0]);

            let pos = 512;
            let count = 0;

            while (pos < data.length) {
                let currentBlockSize = (count === 0) ? 15872 : 16384;
                if (pos + currentBlockSize > data.length) break;

                let block = data.subarray(pos, pos + currentBlockSize);
                pos += currentBlockSize;

                if (block.length < 12318) break;

                for (let i = 0; i < 15; i++) {
                    let b1 = block[12288 + i * 2], b2 = block[12288 + i * 2 + 1];
                    let r = (b1 >> 4) & 0x07, b = b1 & 0x07, g = b2 & 0x07;
                    palette[i + 1] = rgb333_to_888(r, g, b);
                }

                for (let y = 0; y < 192; y++) {
                    for (let x = 0; x < 256; x++) {
                        let b_idx = Math.floor(y / 8) * 32 + Math.floor(x / 8);
                        let off = b_idx * 8 + (y % 8);
                        let p_byte = block[off], c_byte = block[6144 + off];
                        let fg = c_byte >> 4, bg = c_byte & 0x0F;
                        
                        let isFg = (p_byte & (1 << (7 - (x % 8)))) !== 0;
                        let color = isFg ? palette[fg] : palette[bg];

                        videoBuffer[videoOffset++] = color[0];
                        videoBuffer[videoOffset++] = color[1];
                        videoBuffer[videoOffset++] = color[2];
                    }
                }

                if (block.length > 12800) {
                    let sizeIndicator = block[12800];
                    if (sizeIndicator > 0 && sizeIndicator <= 128) {
                        let chunkSize = sizeIndicator * 32;
                        if (12801 + chunkSize <= block.length) {
                            audioChunks.push(block.slice(12801, 12801 + chunkSize));
                        }
                    }
                }
                if (count % 100 === 0) log(`í”„ë ˆì„ íŒŒì‹± ì¤‘... ${count}/${numBlocks}`);
                count++;
            }

            let totalAudioLength = audioChunks.reduce((acc, val) => acc + val.length, 0);
            let audioBuffer = new Uint8Array(totalAudioLength);
            let aOff = 0;
            for (let chunk of audioChunks) {
                audioBuffer.set(chunk, aOff);
                aOff += chunk.length;
            }

            return { videoBuffer: videoBuffer.subarray(0, videoOffset), audioBuffer };
        }

        startBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('mv2file');
            if (!fileInput.files.length) {
                alert("MV2 íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
                return;
            }
            startBtn.disabled = true;
            downloadBtn.style.display = "none";
            logEl.textContent = "ë³€í™˜ ì‹œì‘...";

            try {
                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();

                log("1. MV2 íŒŒì¼ íŒŒì‹± ë° Raw ë°ì´í„° ì¶”ì¶œ ì¤‘...");
                const { videoBuffer, audioBuffer } = await demuxMV2(arrayBuffer);
                log(`=> ë¹„ë””ì˜¤ Raw ì¶”ì¶œ ì™„ë£Œ: ${(videoBuffer.length/1024/1024).toFixed(2)} MB`);
                log(`=> ì˜¤ë””ì˜¤ MP3 ì¶”ì¶œ ì™„ë£Œ: ${(audioBuffer.length/1024).toFixed(2)} KB`);

                log("2. FFmpeg.wasm ë¡œì»¬ ì½”ì–´ ë¡œë”© ì¤‘...");
                if (!ffmpeg.loaded) {
                    // ğŸ’¡ í•µì‹¬: ì™¸ë¶€ CDN ì£¼ì†Œ ì—†ì´ ë¬´ì¡°ê±´ ë¡œì»¬ì˜ íŒŒì¼ë¡œ êµ¬ë™í•©ë‹ˆë‹¤.
                    await ffmpeg.load({
                        coreURL: 'ffmpeg-core.js',
                        wasmURL: 'ffmpeg-core.wasm'
                    });
                }

                log("3. ë¸Œë¼ìš°ì € ê°€ìƒ íŒŒì¼ ì‹œìŠ¤í…œ(MEMFS)ì— ê¸°ë¡ ì¤‘...");
                await ffmpeg.writeFile('video.raw', videoBuffer);
                await ffmpeg.writeFile('audio.mp3', audioBuffer);

                log("4. Muxing ì‹œì‘ (MP4 ê²°í•©)...");
                await ffmpeg.exec([
                    '-y',
                    '-f', 'rawvideo',
                    '-pix_fmt', 'rgb24',
                    '-s', '256x192',
                    '-r', '15',
                    '-i', 'video.raw',
                    '-i', 'audio.mp3',
                    '-c:v', 'libx264',
                    '-pix_fmt', 'yuv420p',
                    '-c:a', 'copy',
                    '-shortest',
                    'output.mp4'
                ]);

                log("5. íŒŒì¼ ë³€í™˜ ì™„ë£Œ! ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.");
                const data = await ffmpeg.readFile('output.mp4');
                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                const url = URL.createObjectURL(blob);
                
                downloadBtn.href = url;
                downloadBtn.download = file.name.replace(/\.[^/.]+$/, "") + ".mp4";
                downloadBtn.style.display = "inline-block";
                
                ffmpeg.deleteFile('video.raw');
                ffmpeg.deleteFile('audio.mp3');
                ffmpeg.deleteFile('output.mp4');

            } catch (error) {
                log(`âŒ ì—ëŸ¬ ë°œìƒ: ${error.message}`);
                console.error(error);
            } finally {
                startBtn.disabled = false;
            }
        });
    </script>
</body>
</html>
